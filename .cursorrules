# Cursor Rules for WaeLab

## fal-ai-mock

This project implements a zero-cost development environment for fal.ai video generation models using dynamic schema fetching and comprehensive mocking. The system automatically switches between mock (development) and real (production) fal.ai clients based on environment.

### Architecture

#### 1. Core Components

##### Constants (`src/lib/constants.ts`)

- **Models Array**: Contains model IDs, names, and pricing
- **Dynamic URL Generation**: `getModelUrls()` generates schema/LLMs URLs from model IDs
- **Fallback Preview URLs**: `getModelPreviewUrl()` provides reliable preview videos for development

##### Schema Fetcher (`src/lib/utils/schema-fetcher.ts`)

- **OpenAPI 3.0.4 Types**: Proper TypeScript interfaces for fal.ai schemas
- **Dynamic Schema Fetching**: Fetches real API schemas from fal.ai endpoints
- **Next.js Caching**: Uses `unstable_cache` with 1-hour revalidation
- **Robust Parsing**: Extracts input/output schemas, constraints, and preview URLs
- **Fallback Handling**: Graceful degradation when schema fetching fails

##### Mock Client (`src/lib/mocks/falMock.ts`)

- **Perfect API Simulation**: Mimics exact fal.ai client behavior
- **Dynamic Validation**: Uses fetched schemas for input validation
- **Realistic Timing**: Model-specific generation times (6-10 seconds)
- **Preview Video Integration**: Returns actual model preview videos
- **Comprehensive Logging**: Detailed console output for debugging

##### Client Selector (`src/lib/falClient.ts`)

- **Environment-Based Switching**: Development = mock, Production = real
- **Unified Interface**: Same API regardless of environment
- **Type Safety**: Full TypeScript support for both clients

##### Types (`src/lib/types.ts`)

- **Video Generation Interfaces**: Input/output types for all models
- **Model Support**: Handles various video generation models dynamically
- **Parameter Flexibility**: Supports duration, aspect_ratio, cfg_scale, etc.

#### 2. Key Patterns

##### Dynamic Schema Fetching

```typescript
// URLs follow predictable patterns
schema_url: `https://fal.ai/api/openapi/queue/openapi.json?endpoint_id=${modelId}`;
llms_url: `https://fal.ai/models/${modelId}/llms.txt`;

// Preview URLs extracted from schema examples
const previewUrl = outputSchema?.properties?.video?.examples?.[0]?.url;
```

##### Environment-Based Client Selection

```typescript
export const falClient: FalClient =
  process.env.NODE_ENV === "development" ? falMock : fal;
```

##### Schema Validation

```typescript
// Validates against actual fal.ai API constraints
const validationResult = validateInput(input, modelInfo.schema);
if (!validationResult.isValid) {
  throw new Error(`Invalid input: ${validationResult.errors.join(", ")}`);
}
```

#### 3. Model Support

##### Dynamic Model Discovery

- **No Hardcoded Model Lists**: Models are discovered dynamically from constants
- **Schema-Driven Validation**: Each model's capabilities determined from OpenAPI schemas
- **Extensible Architecture**: New models can be added without code changes

##### Model Parameter Support

- **Common Parameters**: `prompt`, `duration` (model-specific options)
- **Advanced Features**: `negative_prompt`, `cfg_scale`, `prompt_optimizer` (when supported)
- **Automatic Detection**: Model capabilities detected from schema, not hardcoded

#### 4. Development Workflow

##### Zero-Cost Development

1. Mock client automatically active in development
2. Real fal.ai schemas fetched and cached
3. Preview videos from actual model examples
4. No API credits consumed during development

##### Production Deployment

1. Set `NODE_ENV=production`
2. Real fal.ai client automatically used
3. No code changes required
4. Full production functionality

#### 5. Error Handling

##### Graceful Degradation

- Schema fetching failures fall back to hardcoded defaults
- Network issues don't break development experience
- Comprehensive error logging for debugging

##### Fallback Mechanisms

- Hardcoded preview URLs when schema examples unavailable
- Default parameter constraints when parsing fails
- Mock generation continues even with schema issues

#### 6. Performance Optimizations

##### Caching Strategy

- **Schema Cache**: 1-hour revalidation for OpenAPI schemas
- **LLMs Cache**: 1-hour revalidation for documentation
- **Tag-Based Invalidation**: Selective cache clearing per model

##### Mock Performance

- **Realistic Timing**: Simulates actual API response times
- **Efficient Validation**: Schema parsing only when needed
- **Memory Management**: No unnecessary object creation

#### 7. Testing & Validation

##### Input Validation

- **Prompt Length**: Respects model-specific limits (2000-2500 chars)
- **Parameter Ranges**: Validates cfg_scale, duration, aspect_ratio
- **Required Fields**: Ensures prompt is always provided

##### Output Simulation

- **File Metadata**: Realistic file sizes, names, and types
- **Video URLs**: Actual preview videos from fal.ai
- **Response Format**: Matches real API exactly

#### 8. Best Practices

##### Code Organization

- **Separation of Concerns**: Mock logic separate from business logic
- **Type Safety**: Full TypeScript coverage with proper interfaces
- **Error Boundaries**: Graceful handling of all failure scenarios

##### Maintainability

- **Dynamic URLs**: No hardcoded fal.ai endpoints
- **Schema-Driven**: Validation based on actual API specifications
- **Environment-Aware**: Automatic client selection

#### 9. Troubleshooting

##### Common Issues

1. **Schema Fetching Fails**: Check network connectivity to fal.ai
2. **Preview Videos Broken**: Verify fallback URLs in constants
3. **Type Errors**: Ensure OpenAPI interfaces match actual schemas
4. **Mock Not Working**: Verify `NODE_ENV=development`

##### Debug Mode

- Console logs show mock generation progress
- Schema fetching status displayed
- Validation errors provide detailed feedback

#### 10. Future Enhancements

##### Potential Improvements

- **Real-time Schema Updates**: Webhook-based cache invalidation
- **Advanced Mocking**: Error scenario simulation
- **Performance Metrics**: Mock vs real API timing comparison
- **Schema Versioning**: Support for multiple API versions

## Usage Examples

### Basic Video Generation

```typescript
const result = await falClient.subscribe(
  "fal-ai/kling-video/v2.1/master/text-to-video",
  {
    input: {
      prompt: "A beautiful sunset over mountains",
      duration: "5",
      aspect_ratio: "16:9",
    },
    pollInterval: 5000,
    logs: true,
    onQueueUpdate: (update) => {
      console.log("Status:", update.status);
    },
  },
);
```

### Model-Specific Parameters

```typescript
// Kling models support advanced parameters
if (model.includes("kling")) {
  input.negative_prompt = "blur, distort, and low quality";
  input.cfg_scale = 0.5;
}

// Minimax models support prompt optimization
if (model.includes("minimax")) {
  input.prompt_optimizer = true;
}
```

This implementation provides a production-ready, cost-effective development environment for fal.ai video generation while maintaining full compatibility with the real API.

---

## new-model

# New Model Implementation - Cursor Rules

## Overview

When adding new models to WaeLab, follow these guidelines to ensure the dynamic form system remains robust and extensible. The system is designed to automatically adapt to new model capabilities through OpenAPI schema parsing.

## Critical Requirements

### 1. Schema Analysis First

- **ALWAYS** analyze the model's OpenAPI schema before implementation
- **NEVER** assume parameter types or structures
- **ALWAYS** check for new parameter types not currently handled
- **VERIFY** the model category (text-to-video, image-to-video, text-to-audio, etc.)

### 2. Current System Limitations

The current implementation handles these parameter types:

- `prompt` (string, required)
- `duration` (enum: "5", "6", "10")
- `aspect_ratio` (enum: "16:9", "9:16", "1:1")
- `negative_prompt` (string, optional)
- `cfg_scale` (number, 0-1 range)
- `prompt_optimizer` (boolean, optional)

**Any parameter outside this scope requires system extension.**

### 3. Implementation Checklist

#### Before Adding a Model

- [ ] **Fetch and analyze** the model's OpenAPI schema
- [ ] **Identify new parameter types** not currently supported
- [ ] **Check parameter data types** (string, number, boolean, array, object, file)
- [ ] **Verify parameter constraints** (min/max values, enum options, required fields)
- [ ] **Assess model category** and its specific requirements

#### During Implementation

- [ ] **Add model to constants** with proper pricing
- [ ] **Update fallback preview URLs** if needed
- [ ] **Test schema fetching** works correctly
- [ ] **Verify form rendering** shows all supported parameters
- [ ] **Test parameter validation** and constraints
- [ ] **Ensure cost calculation** works correctly

#### After Implementation

- [ ] **Test with mock client** in development
- [ ] **Verify real API integration** works
- [ ] **Check error handling** for edge cases
- [ ] **Validate user experience** is intuitive

## Model Categories

### Text-to-Video Models (Currently Supported)

- **Input**: Text prompt + optional video settings
- **Parameters**: prompt, duration, aspect_ratio, negative_prompt, cfg_scale, prompt_optimizer
- **Implementation**: ✅ Fully supported

### Image-to-Video Models (Requires Extension)

- **Input**: Image file + text prompt + optional settings
- **New Parameters**: image (file upload), image_preprocessing options
- **Required Changes**: File upload component, image handling logic

### Text-to-Audio Models (Requires Extension)

- **Input**: Text prompt + audio-specific settings
- **New Parameters**: sample_rate, audio_format, voice_style, quality_settings
- **Required Changes**: Audio parameter components, audio-specific validation

## Parameter Type Handling

### Currently Supported Types

```typescript
// String with max length
if (property.type === 'string' && property.maxLength) {
  return <Textarea maxLength={property.maxLength} />;
}

// Enum values
if (property.enum) {
  return <Select options={property.enum} />;
}

// Number with range
if (property.type === 'number' && property.minimum !== undefined) {
  return <Input type="number" min={property.minimum} max={property.maximum} />;
}

// Boolean
if (property.type === 'boolean') {
  return <Switch />;
}
```

### New Types Requiring Implementation

```typescript
// File uploads
if (property.format === 'binary' || property.contentType?.includes('image/')) {
  return <FileUpload accept={property.contentType} />;
}

// Arrays
if (property.type === 'array') {
  return <MultiSelect options={property.items?.enum} />;
}

// Objects
if (property.type === 'object') {
  return <NestedForm properties={property.properties} />;
}
```

## Implementation Steps

### Step 1: Schema Analysis

```typescript
// Fetch model schema
const modelInfo = await ModelSchemaFetcher.getModelInfo(modelId);
const { schema, llms } = modelInfo;

// Analyze input parameters
const inputParams = Object.keys(schema.input);
const newParams = inputParams.filter(
  (param) => !KNOWN_PARAMETERS.includes(param),
);

if (newParams.length > 0) {
  console.warn(`New parameter types detected: ${newParams.join(", ")}`);
  // Implement handling for new types
}
```

### Step 2: Parameter Type Detection

```typescript
function detectParameterType(property: OpenAPISchemaProperty): ParameterType {
  if (property.type === "string") {
    if (property.enum) return "enum";
    if (property.maxLength) return "textarea";
    return "input";
  }

  if (property.type === "number") return "number";
  if (property.type === "boolean") return "switch";
  if (property.type === "array") return "multiSelect";
  if (property.type === "object") return "nestedForm";

  // Handle file uploads
  if (property.format === "binary") return "fileUpload";

  return "fallback";
}
```

### Step 3: Dynamic Field Rendering

```typescript
function renderParameterField(param: string, schema: any) {
  const paramType = detectParameterType(schema.input[param]);

  switch (paramType) {
    case 'input':
      return <Input placeholder={`Enter ${param}`} />;
    case 'textarea':
      return <Textarea maxLength={schema.input[param].maxLength} />;
    case 'select':
      return <Select options={schema.input[param].enum} />;
    case 'switch':
      return <Switch />;
    case 'fileUpload':
      return <FileUpload accept={schema.input[param].contentType} />;
    default:
      return <FallbackField type={paramType} />;
  }
}
```

## Error Handling

### Graceful Degradation

```typescript
try {
  const field = renderParameterField(paramName, schema);
  return field;
} catch (error) {
  console.warn(`Failed to render field for ${paramName}:`, error);
  return <FallbackField name={paramName} />;
}
```

### Fallback UI

```typescript
function FallbackField({ name, type }: { name: string; type: string }) {
  return (
    <div className="p-4 border border-orange-200 bg-orange-50 rounded-lg">
      <p className="text-sm text-orange-800">
        <strong>Unsupported parameter:</strong> {name} ({type})
      </p>
      <p className="text-xs text-orange-600 mt-1">
        This parameter type is not yet supported. Please contact support.
      </p>
    </div>
  );
}
```

## Testing Requirements

### Schema Validation

- [ ] **OpenAPI schema** parses without errors
- [ ] **Input parameters** are correctly identified
- [ ] **Parameter constraints** are properly extracted
- [ ] **Default values** are set correctly

### Form Rendering

- [ ] **All parameters** are displayed
- [ ] **Input validation** works correctly
- [ ] **Parameter dependencies** are handled
- [ ] **Error states** are properly managed

### Integration Testing

- [ ] **Mock client** works with new model
- [ ] **Real API** integration functions
- [ ] **Cost calculation** is accurate
- [ ] **User experience** remains smooth

## Common Pitfalls

### ❌ Don't Do This

- **Hardcode parameter assumptions** based on existing models
- **Skip schema analysis** and assume parameter types
- **Ignore new parameter types** that aren't currently supported
- **Assume all models** follow the same parameter structure

### ✅ Do This Instead

- **Always analyze schemas** before implementation
- **Implement fallback handling** for unknown types
- **Extend the system** to handle new parameter types
- **Test thoroughly** with both mock and real clients
- **Document changes** for future reference

## Success Criteria

A new model is successfully implemented when:

1. **Schema parsing** works without errors
2. **All parameters** are properly displayed in the form
3. **Input validation** respects parameter constraints
4. **Cost calculation** is accurate
5. **User experience** remains intuitive
6. **Existing functionality** is not broken
7. **Error handling** is graceful for edge cases

## Resources

- **Implementation Plan**: `NEW_MODEL_IMPLEMENTATION_PLAN.md`
- **Schema Fetcher**: `src/lib/utils/schema-fetcher.ts`
- **Dynamic Form**: `src/app/dashboard/playground/generate/_components/DynamicModelForm.tsx`
- **Model Constants**: `src/lib/constants.ts`
- **Mock Client**: `src/lib/mocks/falMock.ts`

Follow these guidelines to ensure the dynamic form system remains robust and extensible as new models are added.
